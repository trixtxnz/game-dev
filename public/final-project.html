<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Glitch Maze</title>
    <style>
        /* =========================================
           GLOBAL & PHASE 1 STYLES
           ========================================= */
        body {
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scroll bars during game */
        }

        /* Container for the first game to hide it later */
        #game-phase-1 {
            display: block;
            width: 100%;
            height: 100vh;
            position: relative;
        }

        /* =========================================
           TRANSITION SCREEN STYLES
           ========================================= */
        #transition-screen {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            color: lime;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 9999;
            flex-direction: column;
        }

        #transition-screen h1 {
            font-size: 2rem;
            text-shadow: 2px 2px 5px #003300;
        }

        /* =========================================
           PHASE 2 (STICKMAN) STYLES
           ========================================= */
        #game-phase-2 {
            display: none; /* Hidden by default */
            /* Phase 2 specific body styling applied to container */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            width: 100%;
        }

        .container {
            text-align: center;
        }

        .game-area {
            position: relative;
            width: 900px;
            height: 500px;
            margin: 0 auto;
        }

        canvas {
            display: block;
            border: 4px solid #e94560;
            background: #16213e;
            border-radius: 8px;
        }

        #game-phase-2 p {
            color: #fff;
            margin-top: 10px;
        }

        #game-phase-2 h2 {
            color: #e94560;
            margin-bottom: 5px;
        }

        /* STICK FIGURE CSS */
        .stickman {
            position: absolute;
            width: 42px;
            height: 120px;
            transform-origin: center bottom;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.2s;
        }

        .head {
            width: 20px;
            height: 20px;
            border: 3px solid #fff;
            border-radius: 50%;
            margin: 0 auto;
            box-sizing: content-box;
        }

        .body {
            width: 6px;
            height: 39px;
            background: #fff;
            margin: -3px auto 0;
            border-radius: 3px;
        }

        .upper, .lower {
            position: absolute;
            width: 6px;
            background: #fff;
            border-radius: 3px;
            transform-origin: top;
        }

        .lower { top: 100%; }
        .arm.upper { height: 25px; top: 24px; }
        .arm.lower { height: 18px; top: 21px; }
        .leg.upper { height: 30px; top: 58px; }
        .leg.lower { height: 22px; top: 25.5px; }
        .left  { left: 18.21px; }
        .right { right: 18.21px; }

    </style>
</head>

<body id="myBody" style="background-repeat:repeat; background-size: 80%" background="https://wallpaperaccess.com/full/628286.jpg">

    <div id="game-phase-1" onclick="handleGame1Click()">
        <h1 align="center"><font color="red">T4A04 Maze by Fred</font></h1>

        <input type="button" value="Auto Background Left" onclick="{
            clearInterval(myClock)
            let myTemp = '100px 0px'
            myClock = setInterval(function(){
                myGlobalX -= 5
                myTemp =  myGlobalX + 'px 0px'
                document.getElementById('myBody').style.backgroundPosition = myTemp
            }, 100)
        }"><br><br>

        <img id="myImg01" src="https://tse1.mm.bing.net/th/id/OIP.T1-Es7NCjddWDvXSs9VqgwHaFj?rs=1&pid=ImgDetMain&o=7&rm=3" style="position:absolute; width:100px; height:80px; left: 50px; top:190px;">
        <img id="myImg02" src="https://tse1.mm.bing.net/th/id/OIP.T1-Es7NCjddWDvXSs9VqgwHaFj?rs=1&pid=ImgDetMain&o=7&rm=3" style="position:absolute; width:10px; height:200px; left:350px; top:90px;">
        <img id="myImg03" src="https://tse1.mm.bing.net/th/id/OIP.T1-Es7NCjddWDvXSs9VqgwHaFj?rs=1&pid=ImgDetMain&o=7&rm=3" style="position:absolute; width:200px; height:10px; left:500px; top:400px;">
        <img id="myImg04" src="https://tse1.mm.bing.net/th/id/OIP.T1-Es7NCjddWDvXSs9VqgwHaFj?rs=1&pid=ImgDetMain&o=7&rm=3" style="position:absolute; width:100px; height:80px; left:800px; top:400px;">
        <img id="myImg05" src="https://tse1.mm.bing.net/th/id/OIP.T1-Es7NCjddWDvXSs9VqgwHaFj?rs=1&pid=ImgDetMain&o=7&rm=3" style="position:absolute; width:1000px; height:20px; left:0px; top:600px;">
    </div>

    <div id="transition-screen" style="display:none;">
        <h1>you have nocliped between the demensions</h1>
        <h2>find a way out good luck</h2>
    </div>

    <div id="game-phase-2">
        <div class="container">
            <h2 id="level-display">Level 1</h2>
            <div class="game-area">
                <canvas id="canvas" width="900" height="500"></canvas>

                <div class="stickman" id="player">
                    <div class="head"></div>
                    <div class="body"></div>
                    <div class="upper arm left"><div class="lower arm"></div></div>
                    <div class="upper arm right"><div class="lower arm"></div></div>
                    <div class="upper leg left"><div class="lower leg"></div></div>
                    <div class="upper leg right"><div class="lower leg"></div></div>
                </div>
            </div>

            <p>Goal: Reach the <span style="color:#00ff00; font-weight:bold;">GREEN BOX</span></p>
            <p>Use A/D to move, W/Space to jump. <b>Press Shift change between 2d and 3d space, press r to reset level</b></p>
            <p>level 3 has some bugs sorry about that</p>    
        </div>
    </div>

    <script>
        // --- GAME 1 LOGIC ---
        let myGlobalX = 0
        let myClock
        let myGravity = 0.03
        let myJump = -40;
        let myHorizontalJump = 5;
        let myVertical;
        let myHorizontal;
        let myTimer02; // Made global so we can stop it
        let game1Active = true;

        // Auto start Game 1
        window.onload = function() {
            myAuto();
        };

        function handleGame1Click() {
            if(!game1Active) return;

            // Moves the image right
            document.getElementById('myImg01').style.left = parseInt(document.getElementById('myImg01').style.left) + 10 + 'px'
            // Jump and gravity logic
            document.getElementById('myImg01').style.top = parseInt(document.getElementById('myImg01').style.top) + myJump + 'px'
            myDoGravity()
            myCheckHit() 
        }

        function myHitOther(my1,my2){
            let left1   = parseInt(document.getElementById(my1).style.left)
            let right1  = left1 + parseInt(document.getElementById(my1).style.width)
            let top1    = parseInt(document.getElementById(my1).style.top)   
            let bottom1 = top1    + parseInt(document.getElementById(my1).style.height)
            let left2   = parseInt(document.getElementById(my2).style.left)
            let right2  = left2 + parseInt(document.getElementById(my2).style.width)
            let top2    = parseInt(document.getElementById(my2).style.top)   
            let bottom2 = top2    + parseInt(document.getElementById(my2).style.height)
            if ((right1  >=  left2  ) &&            
                (bottom1 >=  top2   ) &&
                (left1   <=  right2 ) &&
                (top1    <=  bottom2) ){
                return true
            }
        }

        function myDoGravity(){
             myVertical = parseInt(document.getElementById('myImg01').style.top) + 2
             myHorizontal = parseInt(document.getElementById('myImg01').style.left) 
             document.getElementById('myImg01').style.left = myHorizontal + myHorizontalJump
             document.getElementById('myImg01').style.top = myVertical + (myVertical * myGravity) + 'px'
        }

        function myAuto(){
            clearInterval(myClock)
            myTimer02 = setInterval(function(){
                 myDoGravity()
                 myCheckHit()
            }, 100)
        }

        function myCheckHit(){
             // Wall 1 - DEATH TRIGGER
             if ( myHitOther('myImg01','myImg02') ){
                triggerNoclip();
             }   

             // Wall 2 - DEATH TRIGGER
             if ( myHitOther('myImg01','myImg03') ){
                triggerNoclip();
             }   

             // Floor logic - DEATH TRIGGER
             if ( myHitOther('myImg01','myImg05') ){
                triggerNoclip();
             }   

             // Win Goal
             if ( myHitOther('myImg01','myImg04') ){
                 alert('You Win, now go to the next level')
                 document.getElementById('myImg01').style.left = '20px'
                 location = 'https://www.google.ca'
             }
        }

        // --- THE TRANSITION LOGIC ---
        function triggerNoclip() {
            if(!game1Active) return;
            game1Active = false;
            
            // Stop Game 1 Loops
            clearInterval(myClock);
            clearInterval(myTimer02);

            // Hide Game 1
            document.getElementById('game-phase-1').style.display = 'none';
            
            // Remove background image from body to prepare for dark mode
            document.body.style.background = 'black'; 

            // Show Transition Screen
            const ts = document.getElementById('transition-screen');
            ts.style.display = 'flex';

            // Wait 3 seconds, then start Game 2
            setTimeout(() => {
                ts.style.display = 'none';
                startSecondGame();
            }, 3000);
        }

        // --- GAME 2 LOGIC (Wrapped to start on command) ---
        function startSecondGame() {
            // Show Game 2 Container
            const g2 = document.getElementById('game-phase-2');
            g2.style.display = 'flex';
            document.body.style.background = '#1a1a2e'; // Set Game 2 background color

            // Initialize Game 2 Variables
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const playerDOM = document.getElementById("player");
            const levelDisplay = document.getElementById("level-display");

            const gravity = 0.5;
            const jumpStrength = -12;

            let phase = 0;
            let facing = 1;
            let currentLevelIndex = 0;

            const parts = {
                aUL: document.querySelector(".arm.upper.left"),
                aLL: document.querySelector(".arm.upper.left .lower"),
                aUR: document.querySelector(".arm.upper.right"),
                aLR: document.querySelector(".arm.upper.right .lower"),
                lUL: document.querySelector(".leg.upper.left"),
                lLL: document.querySelector(".leg.upper.left .lower"),
                lUR: document.querySelector(".leg.upper.right"),
                lLR: document.querySelector(".leg.upper.right .lower"),
            };

            const levels = [
                {
                    spawn: { x: 100, y: 350 },
                    goal: { x: 800, y: 350, w: 50, h: 50 },
                    walls: [
                        { x: 0, y: 0, width: 900, height: 10 },    
                        { x: 0, y: 490, width: 900, height: 10 },  
                        { x: 0, y: 0, width: 10, height: 500 },    
                        { x: 890, y: 0, width: 10, height: 500 },  
                        { x: 400, y: 375, width: 240, height: 15, rotation: 90 },  
                        { x: -10, y: 130, width: 950, height: 15, rotation: 0 }, 
                    ]
                },
                {
                    spawn: { x: 50, y: 400 },
                    goal: { x: 800, y: 50, w: 50, h: 50 }, 
                    walls: [
                        { x: 0, y: 0, width: 900, height: 10 },    
                        { x: 0, y: 490, width: 900, height: 10 },  
                        { x: 0, y: 0, width: 10, height: 500 },    
                        { x: 890, y: 0, width: 10, height: 500 },  
                        { x: 250, y: 220, width: 30, height: 280, rotation: 0 },
                        { x: 250, y: 0, width: 30, height: 100, rotation: 0 },
                        { x: 500, y: 0, width: 30, height: 380, rotation: 0 },
                        { x: 700, y: 150, width: 200, height: 20, rotation: 0 },
                        { x: 700, y: 150, width: 20, height: 350, rotation: 0 }
                    ]
                },
                {
                    spawn: { x: 50, y: 400 },
                    goal: { x: 820, y: 400, w: 50, h: 50 },
                    ball: { x: 400, y: 219, radius: 25, vx: 0, vy: 0 }, 
                    laser: { x: 650, y: 0, height: 500, active: true }, 
                    walls: [
                        { x: 0, y: 0, width: 900, height: 10 },
                        { x: 0, y: 490, width: 900, height: 10 },
                        { x: 0, y: 0, width: 10, height: 500 },
                        { x: 890, y: 0, width: 10, height: 500 },
                        { x: 300, y: 250, width: 200, height: 15, rotation: 0 },
                        { x: 650, y: 350, width: 10, height: 140, rotation: 0 }, 
                    ]
                }
            ];

            let activeWalls = [];
            let activeGoal = {};
            let activeBall = null;
            let activeLaser = null;

            const player = {
                x: 0, y: 0, width: 42, height: 100.9, speed: 3, vy: 0, onGround: false,
            };

            const keys = {
                jump: false, left: false, right: false, up: false, down: false, noGravity: false
            };

            function loadLevel(index) {
                if (index >= levels.length) {
                    alert("You beat all levels! Restarting...");
                    currentLevelIndex = 0;
                    loadLevel(0);
                    return;
                }
                const level = levels[index];
                activeWalls = level.walls;
                activeGoal = level.goal;
                activeBall = level.ball ? { ...level.ball } : null;
                activeLaser = level.laser ? { ...level.laser } : null;

                player.x = level.spawn.x;
                player.y = level.spawn.y;
                player.vy = 0;
                keys.noGravity = false; 
                levelDisplay.innerText = "Level " + (index + 1);
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W' || e.key === ' ') keys.jump = true;
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
                if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
                if (e.key === 'Shift') keys.noGravity = !keys.noGravity;
                if (e.key === 'r' || e.key === 'R') loadLevel(currentLevelIndex);
            });

            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W' || e.key === ' ') keys.jump = false;
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
                if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
            });

            function idlePose() {
                parts.aUL.style.transform = `rotate(25deg)`;  
                parts.aLL.style.transform = `rotate(5deg)`;   
                parts.aUR.style.transform = `rotate(-25deg)`;  
                parts.aLR.style.transform = `rotate(-5deg)`;   
                parts.lUL.style.transform = `rotate(8deg)`;  
                parts.lLL.style.transform = `rotate(0deg)`;  
                parts.lUR.style.transform = `rotate(-8deg)`;  
                parts.lLR.style.transform = `rotate(0deg)`;  
                playerDOM.style.transform = `translateY(0px) scale(${facing},1)`;
            }

            function walk() {
                phase += 0.12;
                const s = Math.sin(phase);
                const f = Math.max(0, s);
                const b = Math.max(0, -s);
                parts.aUL.style.transform = `rotate(${ s * 20 + 10 }deg)`;
                parts.aLL.style.transform = `rotate(${ f * 15 }deg)`;
                parts.aUR.style.transform = `rotate(${ -s * 20 - 10 }deg)`;
                parts.aLR.style.transform = `rotate(${ b * 15 }deg)`;
                parts.lUL.style.transform = `rotate(${ -s * 28 }deg)`;
                parts.lLL.style.transform = `rotate(${ b * 20 }deg)`;
                parts.lUR.style.transform = `rotate(${ s * 28 }deg)`;
                parts.lLR.style.transform = `rotate(${ f * 20 }deg)`;
                playerDOM.style.transform = `translateY(${ Math.sin(phase*2) * 2 }px) scale(${facing},1)`;
            }

            function getWallCorners(wall) {
                const rot = (wall.rotation || 0) * Math.PI / 180;
                const cx = wall.x + wall.width / 2;
                const cy = wall.y + wall.height / 2;
                const cos = Math.cos(rot);
                const sin = Math.sin(rot);
                const hw = wall.width / 2;
                const hh = wall.height / 2;
                return [
                    { x: cx + (-hw * cos - -hh * sin), y: cy + (-hw * sin + -hh * cos) },
                    { x: cx + (hw * cos - -hh * sin), y: cy + (hw * sin + -hh * cos) },
                    { x: cx + (hw * cos - hh * sin), y: cy + (hw * sin + hh * cos) },
                    { x: cx + (-hw * cos - hh * sin), y: cy + (-hw * sin + hh * cos) }
                ];
            }

            function getBoxCorners(obj) {
                const w = obj.width || (obj.radius * 2);
                const h = obj.height || (obj.radius * 2);
                let x = obj.x;
                let y = obj.y;
                if (obj.radius) { x = obj.x - obj.radius; y = obj.y - obj.radius; }
                return [{ x: x, y: y }, { x: x + w, y: y }, { x: x + w, y: y + h }, { x: x, y: y + h }];
            }

            function projectOnAxis(corners, axis) {
                let min = Infinity, max = -Infinity;
                for (const c of corners) {
                    const proj = c.x * axis.x + c.y * axis.y;
                    min = Math.min(min, proj);
                    max = Math.max(max, proj);
                }
                return { min, max };
            }

            function getAxes(corners) {
                const axes = [];
                for (let i = 0; i < corners.length; i++) {
                    const next = corners[(i + 1) % corners.length];
                    const edge = { x: next.x - corners[i].x, y: next.y - corners[i].y };
                    const len = Math.sqrt(edge.x * edge.x + edge.y * edge.y);
                    axes.push({ x: -edge.y / len, y: edge.x / len });
                }
                return axes;
            }

            function checkRotatedCollision(wall, entity) {
                const wallCorners = getWallCorners(wall);
                const entityCorners = getBoxCorners(entity);
                const axes = [...getAxes(wallCorners), ...getAxes(entityCorners)];
                let minOverlap = Infinity;
                let minAxis = null;
                for (const axis of axes) {
                    const projW = projectOnAxis(wallCorners, axis);
                    const projE = projectOnAxis(entityCorners, axis);
                    if (projW.max < projE.min || projE.max < projW.min) return null;
                    const overlap = Math.min(projW.max - projE.min, projE.max - projW.min);
                    if (overlap < minOverlap) { minOverlap = overlap; minAxis = axis; }
                }
                const wallCenter = { x: wall.x + wall.width / 2, y: wall.y + wall.height / 2 };
                let entityCenter = { x: entity.x + entity.width / 2, y: entity.y + entity.height / 2 };
                if (entity.radius) entityCenter = { x: entity.x, y: entity.y };
                const dir = { x: entityCenter.x - wallCenter.x, y: entityCenter.y - wallCenter.y };
                if (dir.x * minAxis.x + dir.y * minAxis.y < 0) minAxis = { x: -minAxis.x, y: -minAxis.y };
                return { overlap: minOverlap, axis: minAxis };
            }

            function updateBall() {
                if (!activeBall) return;
                const b = activeBall;
                if (!keys.noGravity) b.vy += gravity; else { b.vy *= 0.96; b.vx *= 0.96; }
                b.x += b.vx; b.y += b.vy;
                if (!keys.noGravity) b.vx *= 4;
                for (const wall of activeWalls) {
                    const collision = checkRotatedCollision(wall, b);
                    if (collision) {
                        b.x += collision.axis.x * collision.overlap;
                        b.y += collision.axis.y * collision.overlap;
                        if (Math.abs(collision.axis.y) > 0.5) b.vy *= -0.6; else b.vx *= -0.6;
                    }
                }
                const closestX = Math.max(player.x, Math.min(b.x, player.x + player.width));
                const closestY = Math.max(player.y, Math.min(b.y, player.y + player.height));
                const dx = b.x - closestX;
                const dy = b.y - closestY;
                if ((dx*dx + dy*dy) < (b.radius * b.radius)) {
                    const angle = Math.atan2(dy, dx);
                    const force = 0.1;
                    b.vx += Math.cos(angle) * force;
                    b.vy += Math.sin(angle) * force;
                }
            }

            function updateLaser() {
                if (!activeLaser) return;
                let startY = activeLaser.y;
                let endY = activeLaser.y + activeLaser.height;
                const lx = activeLaser.x;
                if (activeBall) {
                    if (activeBall.x + activeBall.radius > lx && activeBall.x - activeBall.radius < lx) {
                        if (activeBall.y < endY && activeBall.y > startY) endY = activeBall.y - activeBall.radius;
                    }
                }
                activeLaser.currentEndY = endY;
                if (player.x < lx + 2 && player.x + player.width > lx - 2) {
                    if (player.y < endY && player.y + player.height > startY) loadLevel(currentLevelIndex);
                }
            }

            function updatePhysics() {
                let isMoving = false;
                if (keys.left) { player.x -= player.speed; facing = -1; isMoving = true; }
                if (keys.right) { player.x += player.speed; facing = 1; isMoving = true; }
                if (keys.noGravity) {
                    if (keys.up) { player.y -= player.speed; isMoving = true; }
                    if (keys.down) { player.y += player.speed; isMoving = true; }
                    player.vy = 0;
                } else {
                    if (keys.jump && player.onGround) { player.vy = jumpStrength; player.onGround = false; }
                    player.vy += gravity;
                    player.y += player.vy;
                }
                player.onGround = false;
                for (const wall of activeWalls) {
                    const collision = checkRotatedCollision(wall, player);
                    if (collision) {
                        player.x += collision.axis.x * collision.overlap;
                        player.y += collision.axis.y * collision.overlap;
                        if (collision.axis.y < -0.5) { player.vy = 0; player.onGround = true; } 
                        else if (collision.axis.y > 0.5) { player.vy = 0; }
                    }
                }
                updateBall();
                updateLaser();
                if (player.x < activeGoal.x + activeGoal.w && player.x + player.width > activeGoal.x &&
                    player.y < activeGoal.y + activeGoal.h && player.y + player.height > activeGoal.y) {
                    currentLevelIndex++;
                    loadLevel(currentLevelIndex);
                }
                return isMoving;
            }

            function drawEnvironment() {
                ctx.fillStyle = '#e94560';
                for (const wall of activeWalls) {
                    ctx.save();
                    const cx = wall.x + wall.width / 2;
                    const cy = wall.y + wall.height / 2;
                    ctx.translate(cx, cy);
                    ctx.rotate((wall.rotation || 0) * Math.PI / 180);
                    ctx.fillRect(-wall.width / 2, -wall.height / 2, wall.width, wall.height);
                    ctx.restore();
                }
                if (activeBall) {
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(activeBall.x, activeBall.y, activeBall.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                if (activeLaser) {
                    ctx.fillStyle = '#ff0000';
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 20;
                    const h = activeLaser.currentEndY - activeLaser.y;
                    if (h > 0) ctx.fillRect(activeLaser.x - 2, activeLaser.y, 4, h);
                    ctx.shadowBlur = 0;
                }
                ctx.fillStyle = '#00ff00';
                ctx.shadowColor = '#00ff00';
                ctx.shadowBlur = 15;
                ctx.fillRect(activeGoal.x, activeGoal.y, activeGoal.w, activeGoal.h);
                ctx.shadowBlur = 0;
            }

            function updateStickmanVisuals(isMoving) {
                playerDOM.style.left = player.x + "px";
                playerDOM.style.top = player.y + "px";
                isMoving ? walk() : idlePose();
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawEnvironment();
                const isMoving = updatePhysics();
                updateStickmanVisuals(isMoving);
                requestAnimationFrame(animate);
            }

            loadLevel(0);
            animate();
        }
    </script>
</body>
</html>
